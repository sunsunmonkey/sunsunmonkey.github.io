# 高级进阶

## 类型转化

在 Rust 中，将值从一种类型转换为另一种类型通常需要进行显式转
换。这种转换要使用 as 关键字：

``` rust
let x = 17; // x是i32类型的
let index = x as usize; // 转换成usize
```

Rust 允许进行好几种类型的转换。
- 数值可以从任意内置数值类型转换为其他内置数值类型。


将一种整数类型转换为另一种整数类型始终是明确定义的。转换为更窄的类型会导致截断。转换为更宽类型的有符号整数会进行符号扩展，转换为无符号整数会进行零扩展，等等。简而言之，没有意外。
从浮点类型转换为整数类型会向 0 舍入，比如 -1.99 as i32就是 -1。如果值太大而无法容纳整数类型，则转换会生成整数类型可以表示的最接近的值，比如 1e6 as u8 就是 255。


- bool 类型或 char 类型的值或者类似 C 的 enum 类型的值可以转换为任何整数类型。


不允许向相反方向转换，因为 bool 类型、char 类型和 enum类型都对其值有限制，必须通过运行期检查强制执行。例如，禁止将 u16 转换为 char 类型，因为某些 u16 值（如0xd800）对应于 Unicode 的半代用区码点，因此无法生成有效的 char 值。有一个标准方法 std::char::from_u32()，它会执行运行期检查并返回一个 `Option<char>`，但更重要的是，这种转变的需求已经越来越少了。我们通常会一次转换整个
字符串或流，Unicode 文本的算法通常比较复杂，最好留给库去
实现。

